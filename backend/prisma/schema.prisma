// ============================================================
// prisma/schema.prisma - SaaS Engine Pro (PRODUCTION FIXED)
// ============================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================
// ENUMS
// ============================================================

enum Role {
  USER
  ADMIN
  FOUNDER
  SUBSCRIBER // used in admin.service.ts, etc.
}

enum PlanTier {
  FREE
  PRO
  ENTERPRISE
}

enum SubscriptionStatus {
  active
  canceled
  incomplete
  incomplete_expired
  past_due
  paused
  trialing
  unpaid
}

enum AIDraftStatus {
  PENDING
  APPROVED
  REJECTED
}

enum AuditAction {
  // Module lifecycle
  MODULE_CREATED
  MODULE_ARCHIVED
  MODULE_VERSION_CREATED

  // AI Draft governance
  MODULE_APPROVED
  MODULE_REJECTED

  // User governance
  PLAN_UPGRADED
  PLAN_DOWNGRADED
  ROLE_CHANGED

  // Future-proofing / misc
  USER_CREATED
  USER_DELETED
  ACCESS_GRANTED
  ACCESS_REVOKED
}

enum AuditEntityType {
  USER
  MODULE
  AIDRAFT
  SUBSCRIPTION
}

// ============================================================
// MODELS
// ============================================================

model User {
  id           String    @id @default(cuid())
  email        String    @unique
  passwordHash String
  name         String?   // optional display name

  role         Role      @default(USER)
  plan         PlanTier  @default(FREE)

  // ✅ FIX: Soft delete support for GDPR/compliance
  isDeleted    Boolean   @default(false)
  deletedAt    DateTime?

  // Stripe / billing relationships
  stripeCustomerId    String?           @unique
  stripeCustomer      StripeCustomer?
  subscriptions       StripeSubscription[]

  // Auth / security
  passwordResetTokens PasswordResetToken[]

  // Relations
  moduleAccesses   ModuleAccess[]
  aiModuleDrafts   AIModuleDraft[]
  auditLogs        AuditLog[]   @relation("AuditLogPerformedBy")
  publishedModules Module[]     @relation("ModulePublishedBy")

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // ✅ FIX: Index for soft delete queries
  @@index([isDeleted])
  @@index([email, isDeleted])
}

// Stripe customer record (1:1 with User)
model StripeCustomer {
  id         String   @id @default(cuid())
  customerId String   @unique // actual Stripe customer ID

  userId     String   @unique
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model StripeSubscription {
  id                String             @id @default(cuid())
  stripeId          String             @unique       // used in upsert where: { stripeId }
  status            SubscriptionStatus

  // matches billing.service.ts -> new Date(subscription.current_period_end * 1000)
  currentPeriodEnd  DateTime
  cancelAtPeriodEnd Boolean            @default(false)

  // used in billingService.getBillingInfo / syncSubscription
  priceId           String?

  userId            String
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  // ✅ FIX: Critical indexes for subscription queries
  @@index([userId])
  @@index([status])
  @@index([userId, status])
}

// For password reset flows
model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  expiresAt DateTime

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  // ✅ FIX: Index for cleanup jobs
  @@index([expiresAt])
  @@index([userId])
}

model Module {
  id          String   @id @default(cuid())
  name        String
  slug        String
  key         String   @unique
  description String?

  category    String?
  icon        String?
  enabled     Boolean  @default(true)

  minPlan     PlanTier @default(FREE)

  // Versioning fields
  version           Int       @default(1)
  isArchived        Boolean   @default(false)
  publishedAt       DateTime?
  publishedByUserId String?
  publishedByUser   User?     @relation("ModulePublishedBy", fields: [publishedByUserId], references: [id])

  // Traceability: which AI draft created this module (null if manual)
  sourceAIDraftId   String?
  sourceAIDraft     AIModuleDraft? @relation("ModuleFromDraft", fields: [sourceAIDraftId], references: [id])

  // JSON config (matches TS usage of defaultConfig)
  defaultConfig     Json?

  // Relations
  moduleAccesses ModuleAccess[]

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Constraints & Indexes
  @@unique([slug, version])
  @@index([slug])
  @@index([minPlan])
  @@index([isArchived])
  @@index([publishedAt])
}

model ModuleAccess {
  id        String   @id @default(cuid())
  userId    String
  moduleId  String

  // ✅ FIX: Cascade deletes to prevent orphaned records
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  module    Module   @relation(fields: [moduleId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, moduleId])
  // ✅ FIX: Indexes for access lookups
  @@index([userId])
  @@index([moduleId])
}

model AIModuleDraft {
  id          String         @id @default(cuid())
  title       String
  description String?
  status      AIDraftStatus  @default(PENDING)

  // AI-generated previews
  schemaPreview      Json?
  routesPreview      Json?
  permissionsPreview Json?

  // Who requested/created this draft
  createdByUserId String?
  createdByUser   User?   @relation(fields: [createdByUserId], references: [id])

  // Traceability: modules created from this draft
  resultingModules Module[] @relation("ModuleFromDraft")
  
  // If this draft UPDATES an existing module, track which one
  targetModuleSlug String?

  // Review metadata
  reviewedAt       DateTime?
  reviewedByUserId String?
  reviewNote       String?

  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Indexes
  @@index([status])
  @@index([createdByUserId])
  @@index([targetModuleSlug])
}

model AuditLog {
  id                String           @id @default(cuid())
  action            AuditAction
  entityType        AuditEntityType
  entityId          String

  performedByUserId String?
  performedByUser   User?            @relation("AuditLogPerformedBy", fields: [performedByUserId], references: [id])

  metadata          Json?

  createdAt         DateTime         @default(now())

  // Indexes
  @@index([entityType, entityId])
  @@index([performedByUserId])
  @@index([action])
  @@index([createdAt])
  @@index([entityType, action])
}

// ✅ FIX: Webhook idempotency tracking
model ProcessedWebhookEvent {
  id        String   @id // Stripe event ID
  type      String
  createdAt DateTime @default(now())

  @@index([createdAt])
}


